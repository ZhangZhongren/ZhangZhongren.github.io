#  面试题

## [前端基础面试题](https://github.com/qiu-deqing/FE-interview)

## 数组

### 1.  ['1', '2', '3'].map(parseInt) what & why ?

关键点： map接收以一个方法自动传递三个参数 currentVal(当前操作的元素) 、index(当前操作第几个元素)、array
parseInt 接收两个参数 第一个表示被处理的值（字符串），第二个表示为解析时的基数

分布解析 上面的代码

``` js
parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1
parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN
rseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN
```

一维数组可以使用 flat 方法进行深拷贝

### 2. 数组深拷贝

``` js
let arr = [1, 2, 3]
let array = arr // 浅拷贝
let deepArr = arr.slice() // 深拷贝
let deepArr2 = arr.concat() // 深拷贝
let deepArr3 = JSON.parse(JSON.stringify(arr)) // 神拷贝
```

### 3. 数组去重

for循环去重

``` js
  function myFilter(arr) {
    let obj = {};
    let newArr = [];
    for (let i = 0 ; i < arr.length; i ++ ) {
      if (!obj[arr[i]]) {
        newArr.push(arr[i]);
        obj[arr[i]] = 1;
      }
  }
    return newArr;
}
```

利用 indexOf 去重

``` js
function myFilter( arr ) {
  var newArr = [];
  for (var i = 0 ; i < arr.length; i ++ ) {
    if (arr.indexOf(arr[i])== i) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```
利用 includes 实现数组去重

``` js
function myFilter( arr ) {
  var newArr = [];
  for (var i = 0 ; i < arr.length; i ++ ) {
    if (!newArr.includes(arr[i])== i) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```

es6 set 实现数组去重

``` js
function myFilter( arr ) {
  return [...new Set(arr)]
}
```

``` js
Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4]
```

 ### 4. 数组降维（扁平化）

只降一维

``` js
arr.flat() // flat 默认 参数1
```

降低指定的维度 

``` js
arr.flat(n) // n 为 维度数  n > 维度数 降低成一维
```

不确定维度数的数组降低成一维

``` js
arr.flat(Infinity)
```

``` js
[1,[2,3,[4,5]]].toString().split(',')
```

### 5. 数组的排序

利用 sort 方法 实现

``` js
[1,2,3,4].sort((a, b) => a - b); // [1, 2,3,4],默认是升序
[1,2,3,4].sort((a, b) => b - a); // [4,3,2,1] 降序
```

### 6. 数组求最大值

利用Math 的  max 方法实现
``` js
Math.max(...[1,2,3,4]) //4
Math.max.apply(this,[1,2,3,4]) //4
```
利用 reduce 方法实现
``` js
[1,2,3,4].reduce( (prev, cur,curIndex,arr)=> {
 return Math.max(prev,cur);
},0) //4
```

### 7. 数组求和

利用 reduce 实现
``` js
[1,2,3,4].reduce(function (prev, cur) {
   return prev + cur;
 },0) //10 
 ```

## 数据深拷贝

### 1. JSON.parse 和 JSON.stringify 组合使用，可以解决 (有弊端)

``` js
let arr = [{ a: 3, b:2 }]
let newArr = JSON.parse(JSON.stringify(arr))
```
弊端：
> 它的主要缺点是，只限于处理可被 JSON.stringify() 编码的值。

::: tip
JSON.stringify() 将编码 JSON 支持的值。包含 Boolean，Number，String，以及对象，数组。其他任何内容都将被特殊处理。

undefined，Function，Symbol 时，它被忽略掉 Infinity，NaN 会被变成 null Date 对象会被转化为 String (默认调用date.toISOString())
:::

自己实现的一个简单的深拷贝

``` js
/*
  * 
  *
  * 
*/
  class Deepclone {
      getType(source) {
        const str = Object.prototype.toString.call(source);
        const set = {
          '[object Boolean]': 'boolean',
          '[object Number]': 'number',
          '[object String]': 'string',
          '[object Function]': 'function',
          '[object Array]': 'array',
          '[object Date]': 'date',
          '[object RegExp]': 'regExp',
          '[object Undefined]': 'undefined',
          '[object Null]': 'null',
          '[object Object]': 'object'
        };
        if (source instanceof Element) {
          // 判断是否是dom
          return 'element';
        }
        return set[str];
      }
      deepCopy(source) {
        const type = this.getType(source);
        switch (type) {
          case 'array':
            return this._copyArray(source, type);
          case 'object':
            return this._copyObject(source, type);
          case 'function':
            return this._copyFunction(source, type);
          default:
            return source;
        }
      }
      _copyArray(source, type) {
        let copy = []
        for (const [index, value] of source.entries()) {
          copy[index] = this.deepCopy(value);
        }
        return copy;
      }

      _copyObject(source, type) {
        let copy = {}
        for (const [key, value] of Object.entries(source)) {
          copy[key] = this.deepCopy(value);
        }
        return copy;
      }

      _copyFunction(source, type) {
        const fun = eval(source.toString());
        fun.prototype = source.prototype
        return fun
      }
    }

    // 调用
    let deepclone = new Deepclone()
    let data = {
      aaa: [
        {
          a: 1,
          b: 2,
          c: 3,
          zzr: () => {
            console.log(9999)
          }
        }
      ]
    }
    console.log(deepclone.deepCopy(data))
```

