#  面试题

## [前端基础面试题](https://github.com/qiu-deqing/FE-interview)

## 数组

### 1.  ['1', '2', '3'].map(parseInt) what & why ?

关键点： map接收以一个方法自动传递三个参数 currentVal(当前操作的元素) 、index(当前操作第几个元素)、array
parseInt 接收两个参数 第一个表示被处理的值（字符串），第二个表示为解析时的基数

分布解析 上面的代码

``` js
parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1
parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN
rseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN
```

一维数组可以使用 flat 方法进行深拷贝

### 2. 数组深拷贝

``` js
let arr = [1, 2, 3]
let array = arr // 浅拷贝
let deepArr = arr.slice() // 深拷贝
let deepArr2 = arr.concat() // 深拷贝
let deepArr3 = JSON.parse(JSON.stringify(arr)) // 神拷贝
```

### 3. 数组去重

for循环去重

``` js
  function myFilter(arr) {
    let obj = {};
    let newArr = [];
    for (let i = 0 ; i < arr.length; i ++ ) {
      if (!obj[arr[i]]) {
        newArr.push(arr[i]);
        obj[arr[i]] = 1;
      }
  }
    return newArr;
}
```

利用 indexOf 去重

``` js
function myFilter( arr ) {
  var newArr = [];
  for (var i = 0 ; i < arr.length; i ++ ) {
    if (arr.indexOf(arr[i])== i) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```
利用 includes 实现数组去重

``` js
function myFilter( arr ) {
  var newArr = [];
  for (var i = 0 ; i < arr.length; i ++ ) {
    if (!newArr.includes(arr[i])== i) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```

es6 set 实现数组去重

``` js
function myFilter( arr ) {
  return [...new Set(arr)]
}
```

``` js
Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4]
```

 ### 4. 数组降维（扁平化）

只降一维

``` js
arr.flat() // flat 默认 参数1
```

降低指定的维度 

``` js
arr.flat(n) // n 为 维度数  n > 维度数 降低成一维
```

不确定维度数的数组降低成一维

``` js
arr.flat(Infinity)
```

``` js
[1,[2,3,[4,5]]].toString().split(',')
```

### 5. 数组的排序

利用 sort 方法 实现

``` js
[1,2,3,4].sort((a, b) => a - b); // [1, 2,3,4],默认是升序
[1,2,3,4].sort((a, b) => b - a); // [4,3,2,1] 降序
```

### 6. 数组求最大值

利用Math 的  max 方法实现
``` js
Math.max(...[1,2,3,4]) //4
Math.max.apply(this,[1,2,3,4]) //4
```
利用 reduce 方法实现
``` js
[1,2,3,4].reduce( (prev, cur,curIndex,arr)=> {
 return Math.max(prev,cur);
},0) //4
```

### 7. 数组求和

利用 reduce 实现
``` js
[1,2,3,4].reduce(function (prev, cur) {
   return prev + cur;
 },0) //10 
 ```

## 数据深拷贝

### 1. JSON.parse 和 JSON.stringify 组合使用，可以解决 (有弊端)

``` js
let arr = [{ a: 3, b:2 }]
let newArr = JSON.parse(JSON.stringify(arr))
```
弊端：
> 它的主要缺点是，只限于处理可被 JSON.stringify() 编码的值。

::: tip
JSON.stringify() 将编码 JSON 支持的值。包含 Boolean，Number，String，以及对象，数组。其他任何内容都将被特殊处理。

undefined，Function，Symbol 时，它被忽略掉 Infinity，NaN 会被变成 null Date 对象会被转化为 String (默认调用date.toISOString())
:::

自己实现的一个简单的深拷贝

``` js
/*
  * 
  *
  * 
*/
  class Deepclone {
      getType(source) {
        const str = Object.prototype.toString.call(source);
        const set = {
          '[object Boolean]': 'boolean',
          '[object Number]': 'number',
          '[object String]': 'string',
          '[object Function]': 'function',
          '[object Array]': 'array',
          '[object Date]': 'date',
          '[object RegExp]': 'regExp',
          '[object Undefined]': 'undefined',
          '[object Null]': 'null',
          '[object Object]': 'object'
        };
        if (source instanceof Element) {
          // 判断是否是dom
          return 'element';
        }
        return set[str];
      }
      deepCopy(source) {
        const type = this.getType(source);
        switch (type) {
          case 'array':
            return this._copyArray(source, type);
          case 'object':
            return this._copyObject(source, type);
          case 'function':
            return this._copyFunction(source, type);
          default:
            return source;
        }
      }
      _copyArray(source, type) {
        let copy = []
        for (const [index, value] of source.entries()) {
          copy[index] = this.deepCopy(value);
        }
        return copy;
      }

      _copyObject(source, type) {
        let copy = {}
        for (const [key, value] of Object.entries(source)) {
          copy[key] = this.deepCopy(value);
        }
        return copy;
      }

      _copyFunction(source, type) {
        const fun = eval(source.toString());
        fun.prototype = source.prototype
        return fun
      }
    }

    // 调用
    let deepclone = new Deepclone()
    let data = {
      aaa: [
        {
          a: 1,
          b: 2,
          c: 3,
          zzr: () => {
            console.log(9999)
          }
        }
      ]
    }
    console.log(deepclone.deepCopy(data))
```

## 简述TCP协议的三次握手过程

::: tip
核心原理：为了保证数据的正确性，TCP协议中任何一个实体向另一个实体发送同步（SYN)，简单理解就是发送数据，必须获得应答(ACK)。如果任何一次SYN没有获得ACK，那么发送者会认为发送失败。

因此，在建立连接过程中，至少需要这几个步骤：

客户端发送请求

服务端给客户端应答 （至此，客户端认为连接已经建立）

（一个端的应答也是自己给另一个端的请求）客户端给服务端应答（至此，服务端认为连接已经建立）
:::

## 正向代理和反向代理有什么区别？

::: tip
正向代理需要提供代理服务器的IP或域名和HTTP请求，客户端的请求通过正向代理到达目标网站，正向代理的目的是为了给客户端提供更多的上网途径。

反向代理只需要提供HTTP请求，目标网站收到请求后，会将请求转发给内部具体提供服务的服务器，反向代理的目的是为系统内部提供负载均衡、防火墙、目录等服务。
:::

## 请简述CDN的工作原理

::: tip
CDN核心作用是帮助用户加速获取互联网上资源。CND通过在不同地域建立数据中心、购买服务器等方式，让用户可以访问就近的互联网资源，从而有效节省用户获取资源的成本。通过这种方式，CDN可以有效的分散流量，帮助用户降低延迟和提升传输速度。

 
智能DNS

CDN的核心是通常一个智能DNS服务，当有DNS query到达这个智能DNS服务时，它会根据query所在的地域，分配不同的服务器（IP）地址。

 
域名解析处理

一个网络资源比如说一个js文件，要对接CDN有几种方式，一种是将这个网络资源所在域名的ns记录直接指向CDN的智能DNS。这样一个到这个js文件的请求，会先找到CDN上对应的智能DNS，从而将这个请求引导向CDN的资源节点。

另一种方法是将js文件的域名，通过cname记录直接cname到CDN的域名，用户直接请求的就是CDN的域名。然后这个CDN域名再ns到CDN的智能DNS服务。


回源问题

如果CDN资源节点发现请求的资源没有本地缓存，CDN就会尝试请求资源的原始提供方的服务器，这个过程叫回源。
:::

## Http2.0有哪些进步？

::: tip
HTTP2.0主要的目标是提升效率：降低延迟、减少带宽。最核心的3个能力是：多路复用、协议头压缩和服务端推送。

 

多路复用

长连接允许多个请求和响应复用单个TCP连接，多路复用更进一步，允许多个请求和响应拆分成很小的封包，并发传输。这样可以避免部分队头阻塞情况。比如多个请求中的一个阻塞了，其他请求仍然可以到达服务器，服务器可以先计算这些请求需要的结果。

 

压缩HTTP头部

HTTP2.0提出了HPACK压缩算法， 将HTTP协议中可能出现的头部KV组合，比如Method:GET，用一个数字代替。这样可以节省流量。

 

服务端推送

客户端请求HTML文件的时候，HTTP2.0服务器可以分析HTML文件需要的资源，在HTML文件返回的同时，将这些资源同时推送回去。这样可以节省请求次数。
:::


## Zoom面试

1. JS继承
2. WebRTC怎么调用
3. 浏览器音视频解析
4. 播放同步
5. 浏览器缓存
6. Cache-Control用法
7. 事件循环
8. 权限-角色-路由控制
9. CSS伪类
10. 能否通过JS获取伪元素？如果能怎么获取
11. 重绘和回流、优化
12. 伪元素和伪类的区别
13. Flex
14. 水平垂直居中方式
15. Vue生命周期
16. Vue数据绑定原理
17. Vue transition实现原理
18. Vue 2.0怎么实现深度监听
19. display:none、visibility:hidden、opacity:0区别
20. cookie、session区别
21. 怎么让浏览器获取不到cookie
22. 高阶组件
23. XXS和CSRF攻击区别，为什么浏览器会执行攻击的脚本？
24. Vue用了哪些设计模式？
25. 你用过哪些设计模式？

### 二面
1. 浏览器运行
2. 服务器安全
3. canvas
4. websocket压力

## 判断this指向

1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar = new foo()
2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo() 
